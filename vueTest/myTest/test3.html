<!DOCTYPE html>
<html lang="zh" xmlns:v-on="http://www.w3.org/1999/xhtml">
	<html>

	<head>
		<title>表单绑定 事件处理</title>
		<meta charset="utf-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1">
		<link href="..css/style.css" />
		<script src="../js/vue.js"></script>
	</head>

	<body>
		<div id="example-2">
			<!-- `greet` 是在下面定义的方法名 -->
			<button v-on:click="greet">Greet</button>
		</div>
		<script>
			var example2 = new Vue({
				el: '#example-2',
				data: {
					name: 'Vue.js'
				},
				// 在 `methods` 对象中定义方法
				methods: {
					greet: function(event) {
						// `this` 在方法里指向当前 Vue 实例
						alert('Hello ' + this.name + '!')
						// `event` 是原生 DOM 事件
						if(event) {
							alert(event.target.tagName)
						}
					}
				}
			})
		</script>
		<div id="ex1">
			<button v-on:click="warn('Form cannot be submitted yet.', $event)">
 			 Submit
			</button>
		</div>
		<script>
			var ex1 = new Vue({
				el: '#ex1',
				data: {

				},
				methods: {
					warn: function(val, event) {
						if(event) {
							event.preventDefault(); //取消事件的默认动作
							alert(val)
						}

					}
				}

			})
		</script>

		<div id="ex2">

		</div>
		<script>
			/*
			<!-- 阻止单击事件继续传播 -->
			<a v-on:click.stop="doThis"></a>

			<!-- 提交事件不再重载页面 -->
			<form v-on:submit.prevent="onSubmit"></form>

			<!-- 修饰符可以串联 -->
			<a v-on:click.stop.prevent="doThat"></a>

			<!-- 只有修饰符 -->
			<form v-on:submit.prevent></form>

			<!-- 添加事件监听器时使用事件捕获模式 -->
			<!-- 即元素自身触发的事件先在此处处理，然后才交由内部元素进行处理 -->
			<div v-on:click.capture="doThis">...</div>

			<!-- 只当在 event.target 是当前元素自身时触发处理函数 -->
			<!-- 即事件不是从内部元素触发的 -->
			<div v-on:click.self="doThat">...</div>
			<!-- 点击事件将只会触发一次 -->
			<a v-on:click.once="doThis"></a>


			<!-- 滚动事件的默认行为 (即滚动行为) 将会立即触发 -->
			<!-- 而不会等待 `onScroll` 完成  -->
			<!-- 这其中包含 `event.preventDefault()` 的情况 -->
			<div v-on:scroll.passive="onScroll">...</div>
			 * */
			/*
			 * 使用修饰符时，顺序很重要；相应的代码会以同样的顺序产生。因此，用 v-on:click.prevent.self 会阻止所有的点击，
			 * 而 v-on:click.self.prevent 只会阻止对元素自身的点击。
			 */
			//Vue.js 为 v-on 提供了事件修饰符。之前提过，修饰符是由点开头的指令后缀来表示的。
			var ex2 = new Vue({
				el: '#ex2',
				data: {

				},
			})
		</script>

		<div id="ex3">
			<input @keyup.space="clear" type="text">
		</div>
		<script>
			var ex3 = new Vue({
				el: '#ex3',
				data: {

				},
				methods: {
					clear: function() {
						alert("5555555555")
					}
				}
			})
		</script>

		<div id='example-3'>
			<input type="checkbox" id="jack" value="Jack" v-model="checkedNames">
			<label for="jack">Jack</label>
			<input type="checkbox" id="john" value="John" v-model="checkedNames">
			<label for="john">John</label>
			<input type="checkbox" id="mike" value="Mike" v-model="checkedNames">
			<label for="mike">Mike</label>
			<br>
			<span>Checked names: {{ checkedNames }}</span>
			</tr>
			<select v-model="selected">
				<option v-for="option in options" v-bind:value="option.value">
					{{ option.text }}
				</option>
			</select>
			<span>Selected: {{ selected }}</span>
		</div>
		<script>
			var example3 = new Vue({
				el: '#example-3',
				data: {
					checkedNames: [],
					selected: 'A',
					options: [{
							text: 'One',
							value: 'A'
						},
						{
							text: 'Two',
							value: 'B'
						},
						{
							text: 'Three',
							value: 'C'
						}
					]
				},
			})
		</script>
			<div id='example-4'>
				<input v-model.lazy="msg" >
				<b>{{ msg }}</b>

				<input v-model.number="age" type="number">
				<h3>{{ age }}</h3>
			</div>
			<script>
			<!-- .lazy   在'change'时而非'input'时更新 -->
			var example3 = new Vue({
				el: '#example-4',
				data: {
					msg : '',
					age : 0
				}
			})
			</script>

	</body>

	</html>
